<meta charset="utf-8"> 

# Hashlife
![-](imgs/header.png)

The [Hashlife algorithm](https://en.wikipedia.org/wiki/Hashlife) was invented by Bill Gosper in [#Gosper1984] to speed up evaluation of the Game of Life using a hierarchical caching method. 
It is a very ingenious algorithm and one that has some subtlety in implemention. There are several good explanations on the web, including [Tomas Rokicki's Dr. Dobbs article](https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478) and [Jenny Owen's explanation](https://jennyhasahat.github.io/hashlife.html). 

## Game of Life algorithms

There are a huge number of clever ways to implement Conway's Game of Life, from the naive grid counting implementation, to [super fast bit-fiddling like Tony Finch's version](http://dotat.at/prog/life/life.html), to algorithms that rewrite GoL as a different 2x2 16-state automata and simulate that instead and only compute four neighbours instead of nine, like [Callahan's algorithm](https://github.com/johnhw/glgol). There are [asynchronous update algorithms](https://www.researchgate.net/publication/222758581_Asynchronous_game_of_life) and, of course, [implementations in the Game of Life itself](https://www.conwaylife.com/wiki/Unit_cell).

If we have a collection of "on" cells as `(x,y)` pairs, a tiny Python program to compute the next state is:

```python
from collections import Counter
def life(cells):    
    ns = Counter([(x+a, y+b) for x,y in cells for a in [-1,0,1] for b in [-1,0,1]])
    return Counter([p for p in ns if ns[p]==3 or (ns[p]==4 and p in cells)])
```

This implementation has no limits on universe size, other than memory limitations.

The Game of Life is also easy to write as a convolution of a binary matrix, for example with Scipy:

```python
from scipy.ndimage import convolve
k = np.array([1,1,1,1,2,1,1,1,1]).reshape(3,3)
def life(cells):
    result = convolve(cells, k, mode="wrap")
    cells = np.where((result>4) & (result<8), 1, 0) 
```

This is a very simple form to parallelise, e.g. on the GPU.

## Purpose

We want to be able to evaluate a cellular automaton quickly, by pre-caching successors to states we have seen before. To make this efficient, we can cache things hierarchically, in quadtree using a hierarchy over both space and time.

## Algorithm

Assume we have a quadtree, where the children of a node are named ABCD:

**************
*    A B     *
*    C D     *
**************

If we can compute the successor of the "central" block of this node, we can always scan the entire quadtree to compute the complete successor of the quadtree, padding with zeros as needed:


**********************************************************************
* +-----+       |   +-----+        |     +-----+   |       
* | 0 0 | 0 0   | 0 | 0 0 | 0      | 0 0 | 0 0 |   |
* | 0 A | B X   | 0 | A B | X      | 0 A | B X |   |    ...
* +-----+       |   +-----+        |     +-----+   |       
*   0 C   D X   | 0   C  D  X      | 0 C   D X     |
*   0 X   X X   | 0   X  X  X      | 0 X   X X     |
**********************************************************************


We can split a quadtree node into grandchildren (4x4 grid of grandchildren)

****************************
* AA    AB      BA      BB *
*     +------------+       *
* AC  | AD      BC |    BD *
*     |            |       *
* CA  | CB      DA |    DB *
*     +------------+       *
* CC    CD      DC      DD *
****************************

we want to compute the successor of the central region, that is what will be in:

***********
*  ad bc  *
*  cb da  *
***********

in the future (lowercase to indicate the "successor of"). 

We can further split a node into great grandchildren (8x8 grid of great grand children)

*********************************************************************
* AAA   AAB     ABA     ABB         BAA     BAB     BBA     BBB     *
* AAC   AAD     ABC     ABD         BAC     BAD     BBC     BBD     *
*                                                                   *
*            +----------------------------------+                   *
* ACA   ACB  |  ADA     ADB         BCA     BCB |   BDA     BDB     *
* ACC   ACD  |  ADC     ADD         BCC     BCD |   BDC     BDD     *
*            |                                  |                   *
*            |                                  |                   *
* CAA   CAB  |  CBA     CBB         DAA     DAB |   DBA     DBB     *
* CAC   CAD  |  CBC     CBD         DAC     DAD |   DBC     DBD     *
*            +----------------------------------+                   *
*                                                                   *
* CCA   CCB     CDA     CDB         DCA     DCB     DDA     DDB     *
* CCC   CCD     CDC     CDD         DCC     DCD     DDC     DDD     *
*********************************************************************


Now we can find a way to split up the grandchildren of a node
into nine overlapping child-size blocks so that we can compute successors of the size of the grandchildren.
We then subdivide those successor blocks into great-grandchildren
(lowercase indicates successor)

*********************************************************************
*         ╭1╌╌╌╌╌╌╌╮             ╭2╌╌╌╌╌╌╮             ╭3╌╌╌╌╌╌╌╮   *
*AA AB -->╎aad  abc╎    AB BA -->╎abd bac╎   BA BB  -->╎bad  bbc╎   *
*         ╎    +---╎-------------╎-------╎-------------╎---+    ╎   *
*AC AD    ╎acb |ada╎    AD BC    ╎adb bca╎   BC BD     ╎bcb| bda╎   *
*         ╰╌╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╌╯   *
*              |                                           |        *
*         ╭4╌╌╌╌╌╌╌╮             ╭5╌╌╌╌╌╌╮             ╭6╌╌╌╌╌╌╌╮   *
*AC AD -->╎acd |adc╎    AD BC -->╎add bcc╎   BC BD  -->╎bcd| bdc╎   *
*         ╎    |   ╎             ╎       ╎             ╎   |    ╎   *
*CA CB    ╎cab |cba╎    CB DA    ╎cbb daa╎   DA DB     ╎dab| dba╎   *
*         ╰╌╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╌╯   *
*              |                                           |        *
*         ╭7╌╌╌╌╌╌╌╮             ╭8╌╌╌╌╌╌╮             ╭9╌╌╌╌╌╌╌╮   *
*CA CB -->╎cad |cbc╎    CB DA -->╎cbd dac╎   DA DB  -->╎dad| dbc╎   *
*CC CD    ╎    +---╎-------------╎-------╎-------------╎---+    ╎   *
*         ╎ccb  cda╎    CD DC    ╎cdb dca╎   DC DD     ╎dcb  dda╎   *
*         ╰╌╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╯             ╰╌╌╌╌╌╌╌╌╯   *
*                                                                   *
*********************************************************************

Finally, we can select from those great-grandchildren sized
successor blocks the "inner" parts to make up one full child-sized successor
(a 4x4 block of great-grandchild successors)

************************************************************************
*  +-----------------+     +-----------------+                         *
*  |1:D 2:C | 2:D 3:C|     |ada adb ╎ bca bcb|        +-----+          *
*  |4:B 5:A | 5:B 6:A|     |adc add ╎ bcc bcd|        |ad bc|      +-+ *
*  |-----------------| --> |╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌|    --> |     |  --> |N| *  
*  |4:D 5:C | 5:D 6:C|     |cba cbb ╎ daa dab|        |cb da|      +-+ *
*  |7:B 8:A | 8:B 9:A|     |cbc cbd ╎ dac dad|        +-----+          *
*  +-----------------+     +-----------------+                         *
************************************************************************

To terminate the recursion, at the base level, If we have a $k=2$ 4x4 block, we can compute the 2x2 central successor by iterating over all the 3x3 sub-neighbourhoods of 1x1 cells using the standard Life rule (or any other Moore-neighbourhood binary cellular automaton rule we choose):

*********************************************************
* +-----------+              |     +------------+
* |AA  AB  BA | BB           |  AA | AB  BA  BB |
* |AC  AD  BC | BD  --> ad   |  AC | AD  BC  BD | --> bc
* |CA  CB  DA | DB           |  CA | CB  DA  DB |
* +-----------+              |     +------------+
* CC   CD   DC  DD           |  CC   CD  DC  DD
*----------------------------+------------------------------
*  AA  AB  BA  BB            |  AA   AB  BA  BB 
* +------------+             |     +------------+
* | AC  AD  BC | BD          |  AC | AD  BC  BD | 
* | CA  CB  DA | DB  --> cb  |  CA | CB  DA  DB | --> da
* | CC  CD  DC | DD          |  CC | CD  DC  DD |
* +------------+             |     +------------+
**********************************************************



## Levels

Each node has a **level** $k$, where the size of the node is $2^k \times 2^k$.

* level 0 is a 1x1 block which are just binary values
* level 1 is a 2x2 block whose children are level 0 blocks
* level 2 is 4x4 block whose children are level 1 blocks
* level 3 is an 8x8 block whose children are level 2 blocks
* etc.

It doesn't matter much if the basic Life algorithm is slow. We can use basic brute-force, computing the 2x2 successor of a 4x4 cell by straightforward computation.


## Datastructures

* A **quadtree** `qtree` representing the state of the world at step $t$. Each element is a node `node(k, a, b, c, d, n)`, where `n` is the number of on cells in this node (useful for bookkeeping and display)
* A **mapping** `node -> successor` that maps known nodes to their successors.

## Functions

* **centre(node)**  return a node at level `k+1`, which is centered on the given cell:
*****************************************************
*                           +----------------+
*                           | 0   0    0   0 |
*                           |                |
*  +---------+              | 0   A    B   0 |
*  | A    B  |              |                |
*  |         |    -->       | 0   C    D   0 |
*  | C    D  |              |                |
*  +---------+              | 0   0    0   0 |
*                           +----------------+
*****************************************************

* **join(a,b,c,d)** combine four children at level `k-1` to a new node at level `k`. If this turns out to be a cached node, return the cached node. Otherwise, create a new node, and add it to the cache.

*********************************************         
*             +-------+
*             | A   B |      +-+
*             |       |  --> |N|
*             | C   D |      +-+
*             +-------+
*********************************************         

* **successor(node)** return the central successor of a node at time $t+2^{k-2}$, either from the successor cache, or by the recursive rules set out above (caching the result).
******************************************************************************************         
*             +-----------+             
*             | A      B  |           .. .. .. ..  
*             |           |             +-----+   
*             |           |  -->      ..|ad bc|..  
*             | C      D  |           ..|cb da|.. 
*             |           |             +-----+   
*             +-----------+           .. .. .. .. 
******************************************************************************************         

* **expand(node, clip=None)** transform a quadtree into a list of (x,y) cell coordinates that fall inside a given clipping window (e.g. for display).

* **construct(cells)** convert a set of (x,y) coordinates into a quadtree by recursively merging blocks together.

* **advance(node, n)** find the `n`th successor of a given node. Since we compute the $2^{k-2}$th successor of a level $k$ node, we can advance by any $n$ by
using the binary expansion of $n$ to find the successor. For example, a 64x64, $k=6$ node can be advanced 9 generations by advancing each $k=5$ node by 8 generations and each $k=2$ by one generation.


## References

[#Gosper1984]: Gosper, Bill (1984). "Exploiting Regularities in Large Cellular Spaces". Physica D. Elsevier. 10 (1–2): 75–80. doi:10.1016/0167-2789(84)90251-3.


[John H Williamson](https://johnhw.github.io)

[GitHub](https://github.com/johnhw) / [@jhnhw](https://twitter.com/jhnhw)

<link rel="stylesheet" href="../global/style.css" type="text/css" ></link>
<script>
window.markdeepOptions = {tocStyle:'none'};</script>
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>