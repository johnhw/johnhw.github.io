<meta charset="utf-8"> 

#  The smoking gun: nested cellular automata

![The smoking gun](imgs/gunsmoke_header.gif)

## Visualising cellular automata

I've often wondered about ways of *visualising* the [Game of Life](http://conwaylife.com) (GoL), or in general 2D binary cellular automata. Such appealingly complex behaviours arise in the GoL but the computational beauty of the mechanisms feels like it is let down by an often ugly simple display of cell states. For a topic in recreational mathematics, the *recreational* part could be taken more seriously.

![The Gosper Glider Gun](imgs/gun30.gif) 

A display of cell states over time is a simple and complete representation of the internal state of the simulation but it is aesthetically lacking. This post tackles the unimportant but interesting question of how we can make aesthetically pleasing animated visualisations of CAs for human consumption. What might we render that would entertain human eyes?


## What's the problem?

There are three "problems" I see with visualising binary CA:

1. **Patches, not cells** The interesting state is in the local neighbourhoods, not in the binary states themselves.
1. **Dynamics, not snapshots** The dynamics are what are interesting, not the steady state at a given snapshot.
1. **Resolution and hard square edges** A discrete CA has a very definite fixed resolution at which it operates, both in space and time.

The assumption might be that a human observer would form a gestalt impression from an array of cells; but this is hard to do in practice.

### Colouring
To tackle point 1 (patches, not cells), one approach is to colour cells according to some function of their neighbourhood state in time or space, for example:

* by population count
* by longevity
* by functions like "local heat"
* by periodicity
* by entropy (either over patches or over time)
* by future birth/death/remain alive state
* by remapping `n`x`n` binary squares to $2^{2n}$ distinct colours (e.g. 2x2 or 3x3 neighbourhoods)
    * either replacing the display with `n`x`n` chunks directly
    * or applying some spatial upscaling (e.g. averaging) to colour cells according to partial membership of overlapping neighbourhoods.

A few of these are shown below generated by [this Python script](scripts/colour_life.py). 


### Interpolating and reshaping

We can try and mitigate the "hard square edges" by interpolating or rendering with other shapes. We can infer some other function which approximates the discrete state at any given time. This interpolation can happen over space and/or time. For example:

* rendering circles instead of squares
* rendering the cells as weird random patches, as the ZX Spectrum Horizon tape demo that first introduced me to the Game of Life did:
![The Game of Life, circa 1982, from the [Horizons demo tape]() that came with early ZX Spectrums]()
* applying bilinear/bicubic interpolation
* rendering cells as metaballs (or as simple sums of smooth kernels)
* interpolating with a Gaussian Process or any other surface fitting method
* show the connectivity graph of live cells

A few of these are shown below generated by [this Python script](scripts/life_interpolator.py). 

### Strobing and tracking
Periodicity in time and space are some of the most common interesting dynamic behaviours of a Life pattern. Two simple techniques to help visualise this in common use are:

* **strobing** highlighing every `n`th frame. This looks nice with an exponential decay, like an old-fashioned camera flash.
* **tracking** smoothly translating the pixels by a displacement $(\Delta x, \Delta y)$ on each frame (e.g. at `c/4`) so that a spaceship remains in a fixed position over a complete cycle.

Examples below generated by [this Python script](scripts/life_strobe.py). 

### Volume rendering

Stacking time slices of cell states into a 3D volume tackles the problem of dynamics by removing them entirely -- make time into a concrete third spatial dimension instead. [#CITE]

![The Gosper Gun visualised as stacked slices.](imgs/gun3d.lif)

While lighting and shadowing can make some appealing sculptural forms, this type of representation suffers from occlusion issues, and somehow sucks some of the excitement of a dynamic visualisation from the experience -- perhaps it makes the determinism too concrete. 

You can generate your own in Blender using [life_3d.blend](scripts/life_3d.blend).




### Alternative rules
Alternatively we could just change the whole system to another automata where these problems don't occur. Approaches like [SmoothLife]() are (approximate) continuous-space continuous-time automata which don't suffer from point 3 but have so far found to be less rich in their behaviour than the GoL. 

## Nested cellular automata




* The colouring approaches above tackle point 1 (e.g. neighbourhood colouring) and to some degree point 2 (e.g. heat or periodicity colouring).

One approach I have been exploring is to use the Game of Life (or any other CA) to drive *another* cellular automaton. This second CA can run at a higher temporal and spatial resolution and illuminate the dynamics of the evolution of states in an appealing way. This is an attempt to address points 2 and 3.


### Approach 1: Optical flow + advection

Jos Stam's fluid model
Horn-Schunck flow 
from [OpenCV's motion analysis module](https://docs.opencv.org/2.4/modules/legacy/doc/motion_analysis.html)

### Approach 2: Lattice Boltzmann

Link to shadertoy

### Approach 3: "Volume ramming" in Blender

# Epilogue

The Game of Life has no purpose beyond a study of abstract beauty. There is perhaps a role for concrete beauty in that study. Nested cellular automata are one way of exploring alternative aesthetics. 

[#Stam1999]: Stam, J. (1999, July). Stable fluids. In Proceedings of the 26th annual conference on Computer graphics and interactive techniques (pp. 121-128).
[#Horn1981]: Horn, B. K., & Schunck, B. G. (1981, November). Determining optical flow. In Techniques and Applications of Image Understanding (Vol. 281, pp. 319-331). International Society for Optics and Photonics.


<link rel="stylesheet" href="../global/style.css" type="text/css" ></link>
<script>
window.markdeepOptions = {tocStyle:'none'};</script>
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>